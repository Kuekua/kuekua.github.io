<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      DeepLearning读书笔记1-基础知识篇 | Kuekua&#39;s blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Kuekua Wu">
    
    

    <meta name="description" content="An MIT Press book Ian Goodfellow and Yoshua Bengio and Aaron Courville  英文原版    感谢大神在GitHub上共享自己的中文翻译  ：  Deep-Learning中文PDF版     1. 线性代数1.1  张量在某些情况下，我们会讨论坐标超过两维的数组。 一般地，一个数组中的元素分布在若干维坐标的规则网格中，我们称之为张">
<meta name="keywords" content="Machine Learning,Algorithm,Deep Learning">
<meta property="og:type" content="article">
<meta property="og:title" content="DeepLearning读书笔记1-基础知识篇 | Kuekua&#39;s blog">
<meta property="og:url" content="http://yoursite.com/2017/08/01/DeepLearning读书笔记1-基础知识篇/index.html">
<meta property="og:site_name" content="Kuekua&#39;s blog">
<meta property="og:description" content="An MIT Press book Ian Goodfellow and Yoshua Bengio and Aaron Courville  英文原版    感谢大神在GitHub上共享自己的中文翻译  ：  Deep-Learning中文PDF版     1. 线性代数1.1  张量在某些情况下，我们会讨论坐标超过两维的数组。 一般地，一个数组中的元素分布在若干维坐标的规则网格中，我们称之为张">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://img.blog.csdn.net/20170817103714165?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/">
<meta property="og:image" content="http://img.blog.csdn.net/20170822171450834?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/40/fill/I0JBQkFCMA==/di
ssolve/70/gravity/SouthEast">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?f\left&space;(&space;x&space;\right&space;)=f\left&space;(&space;x_k&space;\right&space;)+{f}%27\left&space;(&space;x_k&space;\right&space;)\left&space;(&space;x-x_k&space;\right&space;)+\frac{1}{2}{f}%27%27\left&space;(&space;x_k&space;\right&space;)\left&space;(&space;x-x_k&space;\right&space;)^2">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?m_k">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?f\left&space;(&space;x_k+\beta&space;^md_k&space;\right&space;)\leq&space;f\left&space;(&space;x_k&space;\right&space;)+\sigma&space;\beta&space;^mg_k^Td_k">
<meta property="og:image" content="http://img.blog.csdn.net/20170822183505539?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/di
ssolve/7/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170822183419304?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/di
ssolve/7/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170825181336921?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/di
ssolve/7/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20170828114118676?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/di
ssolve/7/gravity/Center">
<meta property="og:image" content="http://img.blog.csdn.net/20171018144947922?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/di
ssolve/70/gravity/Center">
<meta property="og:image" content="http://pic002.cnblogs.com/images/2010/156169/2010112402010597.png">
<meta property="og:image" content="http://img.blog.csdn.net/20170830095345174?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/40/fill/I0JBQkFCMA==/di
ssolve/70/gravity/Center">
<meta property="og:updated_time" content="2017-10-27T08:37:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DeepLearning读书笔记1-基础知识篇 | Kuekua&#39;s blog">
<meta name="twitter:description" content="An MIT Press book Ian Goodfellow and Yoshua Bengio and Aaron Courville  英文原版    感谢大神在GitHub上共享自己的中文翻译  ：  Deep-Learning中文PDF版     1. 线性代数1.1  张量在某些情况下，我们会讨论坐标超过两维的数组。 一般地，一个数组中的元素分布在若干维坐标的规则网格中，我们称之为张">
<meta name="twitter:image" content="http://img.blog.csdn.net/20170817103714165?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Kuekua&#39;s blog</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          YesterDay you said tomorrow!
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">分类</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">DeepLearning读书笔记1-基础知识篇</h1>

    

    <div class="post-meta">
      <time datetime="2017-08-01" class="post-meta__date date">2017-08-01</time> 

      <span class="post-meta__tags tags">

          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/Deep-Learning-Book/">Deep Learning Book</a>
            </font>
          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/Algorithm/">Algorithm</a>, <a class="tags-link" href="/tags/Deep-Learning/">Deep Learning</a>, <a class="tags-link" href="/tags/Machine-Learning/">Machine Learning</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <p><strong>An MIT Press book</strong></p>
<p>Ian Goodfellow and Yoshua Bengio and Aaron Courville</p>
<p><a href="http://www.deeplearningbook.org/" target="_blank" rel="external"> 英文原版 </a>  </p>
<p>感谢大神在GitHub上共享自己的中文翻译  ： <a href="https://github.com/exacity
/deeplearningbook-chinese" target="_blank" rel="external"> Deep-Learning中文PDF版 </a></p>
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>

<h1 id="1-线性代数"><a href="#1-线性代数" class="headerlink" title="1. 线性代数"></a>1. 线性代数</h1><h2 id="1-1-张量"><a href="#1-1-张量" class="headerlink" title="1.1  张量"></a>1.1  张量</h2><p>在某些情况下，我们会讨论坐标超过两维的数组。 一般地，一个数组中的元素分布在若干维坐标的规则网格中，我们称之为张量。</p>
<h2 id="1-2-范数"><a href="#1-2-范数" class="headerlink" title="1.2 范数"></a>1.2 范数</h2><p><div align="center"><br><img src="http://img.blog.csdn.net/20170817103714165?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/" width="60%"> </div></p>
<p><div align="left"></div></p>
<h2 id="1-3-Moore-Penrose-伪逆"><a href="#1-3-Moore-Penrose-伪逆" class="headerlink" title="1.3 Moore-Penrose 伪逆"></a>1.3 Moore-Penrose 伪逆</h2><p>对于非方矩阵而言，其逆矩阵没有定义。 假设在下面的问题中，我们希望通过矩阵A的左逆B来求解线性方程：</p>
<p>$$A  x  =  y$$ </p>
<p>Moore-Penrose 伪逆使我们在这类问题上取得了一定的进展。 矩阵A的伪逆定义为：</p>
<p>$$A  +  =  lim  α  ↘  0  (  A ^⊤ A  +  α  I  )  −  1_{A^⊤}$$</p>
<p>计算伪逆的实际算法没有基于这个定义，而是使用下面的公式：</p>
<p>$$A  +  =  V  D  +  U  ⊤$$</p>
<p>其中，矩阵V，D和U  是矩阵A奇异值分解后得到的矩阵。 对角矩阵D的伪逆D^+是其非零元素取倒数之后再转置得到的。</p>
<p>奇异值分解：</p>
<p>$$A  =  U  D  V  ⊤$$</p>
<p>假设A是一个mxn的矩阵，那么U是一个mxm的矩阵，D是一个mxn的对角矩阵，V是一个nx n的矩阵。</p>
<h2 id="1-4-迹运算"><a href="#1-4-迹运算" class="headerlink" title="1.4 迹运算"></a>1.4 迹运算</h2><p>迹运算返回的是矩阵对角元素的和：</p>
<p>$$Tr  (  A  )  =  ∑   A _{ i  ,  j } $$</p>
<p>迹运算提供了另一种描述矩阵Frobenius 范数的方式：  </p>
<p>$$∥  A  ∥  F  =  Tr  (  A  A  ⊤  )  $$<br>迹运算性质</p>
<p>$$Tr  (  A  B  C  )  =  Tr  (  C  A  B  )  =  Tr  (  B  C  A  )$$</p>
<p>或者更一般地，</p>
<p>$$Tr  (  ∏  i  =  1  n  F  (  i  )  )  =  Tr  (  F  (  n  )  ∏  i  =  1  n  −  1<br>F  (  i  )  ) $$</p>
<h1 id="2-概率与信息论"><a href="#2-概率与信息论" class="headerlink" title="2. 概率与信息论"></a>2. 概率与信息论</h1><h2 id="2-1-协方差"><a href="#2-1-协方差" class="headerlink" title="2.1 协方差"></a>2.1 协方差</h2><p>协方差在某种意义上给出了两个变量线性相关性的强度以及这些变量的尺度：</p>
<p>$$Cov  (  f  (  x  )  ,  g  (  y  )  )  =  E  [  (  f  (  x  )  −  E  [  f  (x)  ]  )  (  g  (  y  )  −  E  [  g  (  y  )  ]  )  ] $$</p>
<h2 id="2-2-信息论"><a href="#2-2-信息论" class="headerlink" title="2.2 信息论"></a>2.2 信息论</h2><p>香农熵：  </p>
<p>$$H  (  x  )  =  E  x  ∼  P  [  I  (  x  )  ]  =  −  E  x  ∼  P  [ log (x)  ]$$</p>
<p>一个分布的香农熵是指遵循这个分布的事件所产生的期望信息总量。 它给出了对依据概率分布<br>P生成的符号进行编码所需的比特数在平均意义上的下界(当对数底数不是2时，单位将有所不同)。  </p>
<p>如果我们对于同一个随机变量 x有两个单独的概率分布 P(x)和Q(x)，我们可以使用KL散度来衡量这两个分布的差异：</p>
<p>$$D  KL  (  P  |  |  Q  )  =  E  x  ∼  P  [  log  P  (  x  )  Q  (  x  )  ]  =E  x  ∼  P  [  log  P  (  x  )  −  log  Q  (  x  )  ]  $$</p>
<p>在离散型变量的情况下，KL散度衡量的是，当我们使用一种被设计成能够使得概率分布 Q产生的消息的长度最小的编码，发送包含由概率分布<br>P产生的符号的消息时，所需要的额外信息量。  KL散度是非负的并且衡量的是两个分布之间的差异，它经常被用作分布之间的某种距离。</p>
<p>交叉熵：</p>
<p>$$H  (  P  ,  Q  )  =  −  E  x  ∼  P  log  Q  (  x  ) = H(P) +  D  KL  (  P  ||  Q  )$$</p>
<p>最小化交叉熵等价于最小化KL散度，因为当P已知时，H（P）是常量。</p>
<h1 id="3-数值计算"><a href="#3-数值计算" class="headerlink" title="3. 数值计算"></a>3. 数值计算</h1><h2 id="3-1-方向导数"><a href="#3-1-方向导数" class="headerlink" title="3.1 方向导数"></a>3.1 方向导数</h2><p>方向导数  ：是一个数；  反映的是f(x,y)在P0点沿方向v的变化率。</p>
<p><div align="center"><br><img src="http://img.blog.csdn.net/20170822171450834?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/40/fill/I0JBQkFCMA==/di
ssolve/70/gravity/SouthEast" width="60%" align="center">  </div></p>
<p><div align="left"><br>梯度的方向就是函数f(x,y)在这点增长最快的方向，梯度的模为方向导数的最大值。  </div></p>
<p>最速下降法就是使点的搜索方向与梯度方向相反，达到更为快速收敛的目的。</p>
<h2 id="3-2-基本牛顿法"><a href="#3-2-基本牛顿法" class="headerlink" title="3.2 基本牛顿法"></a>3.2 基本牛顿法</h2><p>基本牛顿法是一种是用导数的算法，它每一步的迭代方向都是沿着当前点函数值下降的方向。</p>
<p>我们主要集中讨论在一维的情形，对于一个需要求解的优化函数 f(x)，求函数的极值的问题可以转化为求函数导函数，对函数 f(x)进行泰勒展开到二阶，得到<br><img src="http://latex.codecogs.com/gif.latex?f\left&amp;space;(&amp;space;x&amp;space;\right&amp;space;)=f\left&amp;space;(&amp;space;x_k&amp;space;\right&amp;space;)+{f}%27\left&amp;space;(&amp;space;x_k&amp;space;\right&amp;space;)\left&amp;space;(&amp;space;x-x_k&amp;space;\right&amp;space;)+\frac{1}{2}{f}%27%27\left&amp;space;(&amp;space;x_k&amp;space;\right&amp;space;)\left&amp;space;(&amp;space;x-x_k&amp;space;\right&amp;space;)^2" _xhe_src="http://latex.codecogs.com/gif.latex?f\left&amp;space;(&amp;space;x&amp;space;\right&amp;space;)=f\left&amp;space;(&amp;space;x_k&amp;space;\right&amp;space;)+{f}%27\left&amp;space;(&amp;space;x_k&amp;space;\right&amp;space;)\left&amp;space;(&amp;space;x-x_k&amp;space;\right&amp;space;)+\frac{1}{2}{f}%27%27\left&amp;space;(&amp;space;x_k&amp;space;\right&amp;space;)\left&amp;space;(&amp;space;x-x_k&amp;space;\right&amp;space;)^2" title="f\left ( x \right )=f\left ( x_k \right )+{f}'\left ( x_k \right )\left ( x-x_k \right )+\frac{1}{2}{f}''\left ( x_k \right )\left ( x-x_k \right )^2" alt="" style="border:none; max-width:100%"></p>
<p>对上式求导并令其为0，<br>即得到<br>$$ x=x_k - f’(x_k)/f”(x_k) $$</p>
<p>这就是牛顿法的更新公式。</p>
<p><strong>流程：</strong></p>
<ol>
<li>给定终止误差值 0&lt;= ε &lt;&lt;1，初始点 $$x_0∈R^n$$，令 k=0; </li>
<li>计算$$g_k =  △f(x_k)$$，若 $$||g_k|| &lt;= ε$$，则停止，输出 $$x* ≈ x_k$$ ； </li>
<li>计算 $$G_k = △^2f(x_k)$$ ，并求解线性方程组得解$$d_k : G_kd = -g_k$$</li>
<li>令 $$x_{k+1}=x_k+d_k,k=k+1$$ ，并转2。 </li>
</ol>
<h2 id="3-3-全局牛顿法"><a href="#3-3-全局牛顿法" class="headerlink" title="3.3 全局牛顿法"></a>3.3 全局牛顿法</h2><p>牛顿法最突出的优点是收敛速度快，具有局部二阶收敛性，但是，基本牛顿法初始点需要足够“靠近”极小点，否则，有可能导致算法不收敛。这样就引入了全局牛顿法。</p>
<p><strong>流程</strong></p>
<ol>
<li>给定终止误差值 $$0&lt;= ε &lt;&lt;1,δ∈(0,1),σ∈(0,0.5)$$，初始点 $$x_0∈R^n$$,令 k=0； </li>
<li>计算 $$g_k =  △f(x_k)$$ ，若 $$||g_k|| &lt;= ε$$，则停止，输出 $$x* ≈ x_k$$ ； </li>
<li>计算 $$G_k =  △^2f(x_k)$$ ，并求解线性方程组得解$$d_k : G_kd = -g_k$$ ;</li>
<li>记 $$m_k$$是不满足下列不等式的最小非负整数 $$m:f(x_k +δ^md_k) &lt;= f(x_k)+σδ^mg_k^Td_k;$$； </li>
<li>令 $$α_k=δ^{m<em>k}，x</em>{k+1}=x_k+α_kd_k，k=k+1$$，并转2。 </li>
</ol>
<h2 id="Armijo搜索"><a href="#Armijo搜索" class="headerlink" title="Armijo搜索"></a>Armijo搜索</h2><p>全局牛顿法是基于  Armijo  的搜索，满足  Armijo  准则：</p>
<p>给定β∈(0,1),σ∈(0,0.5)，令步长因子$$α_k=β^{m<em>k}，x</em>{k+1}=x_k+α_kd_k，k=k+1$$，其中 <img src="http://latex.codecogs.com/gif.latex?m_k" alt=""> 是满足下列不等式的最小非负整数:</p>
<p><img src="http://latex.codecogs.com/gif.latex?f\left&amp;space;(&amp;space;x_k+\beta&amp;space;^md_k&amp;space;\right&amp;space;)\leq&amp;space;f\left&amp;space;(&amp;space;x_k&amp;space;\right&amp;space;)+\sigma&amp;space;\beta&amp;space;^mg_k^Td_k" _xhe_src="http://latex.codecogs.com/gif.latex?f\left&amp;space;(&amp;space;x_k+\beta&amp;space;^md_k&amp;space;\right&amp;space;)\leq&amp;space;f\left&amp;space;(&amp;space;x_k&amp;space;\right&amp;space;)+\sigma&amp;space;\beta&amp;space;^mg_k^Td_k" title="f\left ( x_k+\beta ^md_k \right )\leq f\left ( x_k \right )+\sigma \beta ^mg_k^Td_k" alt="" style="border:none; max-width:100%"></p>
<h2 id="3-4-KKT条件"><a href="#3-4-KKT条件" class="headerlink" title="3.4 KKT条件"></a>3.4 KKT条件</h2><p><a href="http://www.cnblogs.com/zhangchaoyang/articles/2726873.html" target="_blank" rel="external"> 拉格朗日乘子法和KKT条件  </a></p>
<p><div align="center"><br><img src="http://img.blog.csdn.net/20170822183505539?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/di
ssolve/7/gravity/SouthEast" width="50%" align="center">  </div></p>
<div align="left">  

<p><div align="center"><br><img src="http://img.blog.csdn.net/20170822183419304?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/di
ssolve/7/gravity/SouthEast" width="50%" align="center">  </div></p>
<div align="left"> 



<h1 id="4-机器学习基础"><a href="#4-机器学习基础" class="headerlink" title="4. 机器学习基础"></a>4. 机器学习基础</h1><h2 id="4-1-学习算法"><a href="#4-1-学习算法" class="headerlink" title="4.1 学习算法"></a>4.1 学习算法</h2><p><strong>机器学习定义</strong></p>
<p>对于某类任务T和性能度量 P，一个计算机程序被认为可以从经验 E中学习是指，通过经验 E改进后，它在任务T上由性能度量 P衡量的性能有所提升。 </p>
<p><strong>无监督学习算法</strong></p>
<p>训练含有很多特征的数据集，然后学习出这个数据集上有用的结构性质。 在深度学习中，我们通常要学习生成数据集的整个概率分布，显式地，比如密度估计，或是隐式地，比如合成或去噪。 还有一些其他类型的无监督学习任务，例如聚类，将数据集分成相似样本的集合。 </p>
<p><strong>监督学习算法</strong> </p>
<p>训练含有很多特征的数据集，不过数据集中的样本都有一个标签或目标。 例如，Iris数据集注明了每个鸢尾花卉样本属于什么品种。 监督学习算法通过研究Iris数据集，学习如何根据测量结果将样本划分为三个不同品种。 </p>
<p><strong>欠拟合</strong> </p>
<p>是指模型不能在训练集上获得足够低的误差。 而 <strong>过拟合</strong> 是指训练误差和和测试误差之间的差距太大。 </p>
<h2 id="4-2-交叉验证"><a href="#4-2-交叉验证" class="headerlink" title="4.2 交叉验证"></a>4.2 交叉验证</h2><p><strong>验证集：</strong> </p>
<p>训练数据分成两个不相交的子集。 其中一个用于学习参数，另一个作为验证集，用于估计训练中或训练后的泛化误差，更新超参数。  由于验证集是用来”训练”超参数的，尽管验证集的误差通常会比训练集误差小，验证集会低估泛化误差。 所有超参数优化完成之后，泛化误差可能会通过测试集来估计。    </p>
<p><strong>k折交叉验证过程：</strong> </p>
<p>将数据集分成k个不重合的子集。 测试误差可以估计为k次计算后的平均测试误差。 在第i次测试时，数据的第i个子集用于测试集，其他的数据用于训练集。    </p>
<h2 id="4-3-点估计"><a href="#4-3-点估计" class="headerlink" title="4.3 点估计"></a>4.3 点估计</h2><p>令$${x(1),…,x^(m)}$$是m个独立同分布的数据点。 点估计或统计量是这些数据的任意函数：</p>
<p>$$θ  ^  m  =  g  (  x  (  1  )  ,  …  ,  x  (  m  )  )  $$</p>
<p>这个定义不要求g返回一个接近真实θ的值，或者g的值域恰好是  θ  的允许取值范围。 点估计的定义非常宽泛，给了估计量的设计者极大的灵活性。<br>虽然几乎所有的函数都可以称为估计量，但是一个良好的估计量的输出会接近生成训练数据的真实参数  θ  。  </p>
<h2 id="4-4-一致性"><a href="#4-4-一致性" class="headerlink" title="4.4 一致性"></a>4.4 一致性</h2><p><div align="center"><br><img src="http://img.blog.csdn.net/20170825181336921?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/di
ssolve/7/gravity/Center" width="60%" align="center">  </div></p>
<div align="left">   



<h2 id="4-5-最大似然估计（MLE）"><a href="#4-5-最大似然估计（MLE）" class="headerlink" title="4.5 最大似然估计（MLE）"></a>4.5 最大似然估计（MLE）</h2><p><div align="center"><br><img src="http://img.blog.csdn.net/20170828114118676?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/di
ssolve/7/gravity/Center" width="60%" align="center">  </div></p>
<div align="left"> 

<p>通常运用于解决 <strong>模型已知，参数未知</strong> 的情况！</p>
<p>注意：最大似然估计只考虑某个模型能产生某个给定观察序列的概率。而未考虑该模型本身的概率，这点与贝叶斯估计区别。  </p>
<p><strong>最大似然估计解决线性回归</strong></p>
<p>设样本数据数据（xi,yi）,现用线性方程的形式去做回归，线性方程结构为：y=f(x)+e,其中f(x)=w<em>x，w是我们要进行估计的参数向量，e是噪声，且<br>该噪声服从均值为0高斯分布，即：$$e~N(0,sigema^2)$$.<br>假设有一个w（此w并不是最终的w），对于 <strong> 每一个 </strong> 实际得到的数据我们都可以看成是由均值为w</em>xi,方差为$$sigema^2$$的一个高斯模型生成的。但<br>是在w不定的情况下，高斯模型有无数种可能，我们需要从中选择一个我们想要的，而选择需要一个准则，该准则就是：使得在该模型下生成我们获得的数据的可能性最大。<br>问题来了，什么叫可能性最大？怎样来衡量？——&gt;将每一个数据产生的概率连乘起来（似然函数），将该值最为总的数据产生的可能性。很容易理解。</p>
<h2 id="4-6-贝叶斯估计"><a href="#4-6-贝叶斯估计" class="headerlink" title="4.6 贝叶斯估计"></a>4.6 贝叶斯估计</h2><p><a href="http://blog.csdn.net/guohecang/article/details/52313046" target="_blank" rel="external"> 先验概率、最大似然估计、贝叶斯估计、最大后验概率</a></p>
<p><a href="http://www.cnblogs.com/little-YTMM/p/5399532.html" target="_blank" rel="external">贝叶斯思想以及与最大似然估计、最大后验估计的区别</a></p>
<p>贝叶斯估计，是在给定训练数据D时，确定假设空间H中的最佳假设。 最佳假设：一种方法是把它定义为在给定数据D以及H中不同假设的先验概率的有关知识下的最可能假设<br>。贝叶斯理论提供了一种计算假设概率的方法，基于假设的先验概率、给定假设下观察到不同数据的概率以及观察到的数据本身。</p>
<p>1、 <strong>先验分布</strong> 。总体分布参数θ的一个概率分布。贝叶斯学派的根本观点，是认为在关于总体分布参数θ的任何统计推断问题中，除了使用样本所提供的信息外<br>，还必须规定一个先验分布，它是在进行统计推断时不可缺少的一个要素。他们认为先验分布不必有客观的依据，可以部分地或完全地基于主观信念。</p>
<p>2、 <strong>后验分布</strong> 。根据样本分布和未知参数的先验分布，用概率论中求条件概率分布的方法，求出的在样本已知下，未知参数的条件分布。因为这个分布是在抽样<br>以后才得到的，故称为后验分布。贝叶斯推断方法的关键是任何推断都必须且只须根据后验分布，而不能再涉及样本分布。</p>
<p>贝叶斯公式为：</p>
<p>$$P(A∩B)=P(A)<em>P(B|A)=P(B)</em>P(A|B)$$</p>
<p>$$P(A|B)=P(B|A)*P(A)/P(B)$$</p>
<p>其中：</p>
<p>1、P(A)是A的先验概率或边缘概率，称作”先验”是因为它不考虑B因素。</p>
<p>2、P(A|B)是已知B发生后A的条件概率  ，也称作A的后验概率  。</p>
<p>3、P(B|A)是已知A发生后B的条件概率，也称作B的后验概率，这里称作似然度  。</p>
<p>4、P(B)是B的先验概率或边缘概率，这里称作标准化常量。</p>
<p>5、P(B|A)/P(B)称作标准似然度。</p>
<h2 id="4-7-最大后验概率（MAP）"><a href="#4-7-最大后验概率（MAP）" class="headerlink" title="4.7 最大后验概率（MAP）"></a>4.7 最大后验概率（MAP）</h2><p><div align="center"><br><img src="http://img.blog.csdn.net/20171018144947922?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/di
ssolve/70/gravity/Center" width="60%" align="center">  </div></p>
<div align="left"> 

<p><img src="http://pic002.cnblogs.com/images/2010/156169/2010112402010597.png" alt=""></p>
<p>注：最大后验估计可以看做贝叶斯估计的一种特定形式。</p>
<p><strong>各估计算法的区别：</strong></p>
<ol>
<li>ML（最大似然估计）：就是给定一个模型的参数  θ  ，然后试着  最大化p(D|  θ  )  。即给定参数的情况下，看到样本集的概率。目标是找到使前面概率最大的参数。 <ol>
<li>逻辑回归都是基于ML做的； </li>
<li>缺点：不会把我们的先验知识加入模型中。 </li>
</ol>
</li>
<li>MAP（最大后验估计）：最大化p(  θ  |D)。 </li>
<li>Bayesian：我们的预测是考虑了所有可能的参数，即所有的参数空间（参数的分布） </li>
</ol>
<p>MAP与ML最大的不同在于p(θ)项，MAP可以解决ML缺乏先验知识的缺点，将先验知识加入后，优化损失函数。</p>
<p>其实p(  θ  )项正好起到了正则化的作用。如：如果假设p(  θ  )服从高斯分布，则相当于加了一个  L2 norm  ；如果假设p(θ)服从拉普拉斯分布，则相当于加了一个  L1 norm</p>
<h2 id="4-8-支持向量机（SVM）"><a href="#4-8-支持向量机（SVM）" class="headerlink" title="4.8 支持向量机（SVM）"></a>4.8 支持向量机（SVM）</h2><p>支持向量机的一个重要创新是核技巧。 核技巧观察到许多机器学习算法都可以写成样本间点积的形式。<br>最常用的核函数是高斯核：  </p>
<p>k  (  u  ,  v  )  =  N  (  u  −  v  ;  0  ,  σ^2 )  ,</p>
<p>其中N(x; u, Sigma)是标准正态密度。 这个核也被称为径向基函数核，因为其值沿v中从u向外辐射的方向减小。<br>高斯核对应于无限维空间中的点积，但是该空间的推导没有整数上最小核的示例那么直观。<br>我们可以认为高斯核在执行一种 <strong>模板匹配</strong> 。 训练标签 y相关的训练样本 x变成了类别y的模版。<br>当测试点x‘到x的欧几里得距离很小，对应的高斯核响应很大时，表明x’和模版x非常相似。 该模型进而会赋予相对应的训练标签 y较大的权重。<br>总的来说，预测将会组合很多这种通过训练样本相似度加权的训练标签。</p>
<p>Tips: 利用高斯核函数将低维数据映射到无限维，以达到线性可分的目的。</p>
<h2 id="4-9-k均值聚类"><a href="#4-9-k均值聚类" class="headerlink" title="4.9 k均值聚类"></a>4.9 k均值聚类</h2><p>k均值聚类初始化k个不同的中心点$${u_1},…,u_k}$$，然后迭代交换两个不同的步骤直到收敛。<br>步骤一，每个训练样本分配到最近的中心点ui所代表的聚类i。<br>步骤二，每一个中心点ui更新为聚类i中所有训练样本 xj的均值。  </p>
<p>关于聚类的一个问题是聚类问题本身是病态的。 这是说没有单一的标准去度量聚类的数据在真实世界中效果如何。<br>我们可以度量聚类的性质，例如类中元素到类中心点的欧几里得距离的均值。 这使我们可以判断从聚类分配中重建训练数据的效果如何。<br>然而我们不知道聚类的性质是否很好地对应到真实世界的性质。 此外，可能有许多不同的聚类都能很好地对应到现实世界的某些属性。<br>我们可能希望找到和一个特征相关的聚类，但是得到了一个和任务无关的，同样是合理的不同聚类。  </p>
<h2 id="4-10-随机梯度下降"><a href="#4-10-随机梯度下降" class="headerlink" title="4.10 随机梯度下降"></a>4.10 随机梯度下降</h2><p><div align="center"><br><img src="http://img.blog.csdn.net/20170830095345174?watermark/2/text/aHR0cDovL2Jsb2
cuY3Nkbi5uZXQvdTAxMjU1NDA5Mg==/font/5a6L5L2T/fontsize/40/fill/I0JBQkFCMA==/di
ssolve/70/gravity/Center" width="60%" align="center">  </div></p>
<div align="left">   



<h2 id="4-11-促使深度学习发展的挑战"><a href="#4-11-促使深度学习发展的挑战" class="headerlink" title="4.11 促使深度学习发展的挑战"></a>4.11 促使深度学习发展的挑战</h2><p><strong>维数灾难 </strong> </p>
<p>由维数灾难带来的一个挑战是统计挑战。 统计挑战产生于x的可能配置数目远大于训练样本的数目。</p>
<p><strong>局部不变性和平滑正则化</strong></p>
<p>只要在要学习的真实函数的峰值和谷值处有足够多的样本，那么平滑性假设和相关的无参数学习算法的效果都非常好。<br>当要学习的函数足够平滑，并且只在少数几维变化，这样做一般没问题。 在高维空间中，即使是非常平滑的函数，也会在不同维度上有不同的变化方式。<br>如果函数在不同的区间中表现不一样，那么就非常难用一组训练样本去刻画函数。 如果函数是复杂的（我们想区分多于训练样本数目的大量区间），有希望很好地泛化么？</p>
<p><strong>流形学习</strong></p>
<p>流形指连接在一起的区域。 数学上，它是指一组点，且每个点都有其邻域。 给定一个任意的点，其流形局部看起来像是欧几里得空间。<br>日常生活中，我们将地球视为二维平面，但实际上它是三维空间中的球状流形。<br>机器学习中倾向于更松散地定义一组点，只需要考虑少数嵌入在高维空间中的自由度或维数就能很好地近似。 每一维都对应着局部的变化方向。  </p>
<p>流形学习算法通过一个假设来克服这个障碍，该假设认为Rn中大部分区域都是无效的输入，有意义的输入只分布在包含少量数据点的子集构成的一组流形中，而学习函数的输出<br>中，有意义的变化都沿着流形的方向或仅发生在我们切换到另一流形时。  </p>
</div></div></div></div></div></div>
  </section>

  <section class="post-comments">


<section id="comment">
<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2147613"></script>
<!-- UY END -->
</section>

    
</section>


</article>


            <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kuekua Wu</span>

  
</div>









        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    
  <script type="text/x-mathjax-config">
   MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$$','$$'], ["\\(","\\)"] ],
      displayMath: [ ['$','$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
			    extensions: ["tex2jax.js"],
                jax: ["input/TeX", "output/HTML-CSS"],
                tex2jax: {inlineMath: [['[latex]','[/latex]'],['\\(','\\)']],
				          displayMath: [ ['$','$'], ["\\[","\\]"] ],
						  processEscapes: true
						  },
                "HTML-CSS": { availableFonts: ["TeX"] }						  
            });
        });
    </script>
	


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
				autoDetectHeadings: true,
				enableToTopButton: true,
				displayNow: true,
				title: "文章目录",
				css: {
					fontSize: "16px",
					largeFontSize: "20px",
					},
            });
        });
    </script>


    
    

    <script src="/js/jquery.githubRepoWidget.min.js"></script>


    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
